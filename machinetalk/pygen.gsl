.###  This whole script runs in template mode.
.#
.template 1
.output "generated/$(class.name:c).py"
import zmq
import threading
from fysom import Fysom

from machinetalk.protobuf.types_pb2 import *
from machinetalk.protobuf.message_pb2 import Container


class $(class.name:Pascal)(object):
    def __init__(self, debuglevel=0, debugname='$(class.name)'):
        self.debuglevel = debuglevel
        self.debugname = debugname
        self.thread = None
        self.tx_lock = threading.Lock()
        self.timer_lock = threading.Lock()

        # ZeroMQ
        context = zmq.Context()
        context.linger = 0
        self.context = context
        self.shutdown = context.socket(zmq.PUSH)
        self.shutdown.bind(b'inproc://shutdown')
.if (count(outgoing) > 0)
        self.pipe = context.socket(zmq.PUSH)
        self.pipe.bind(b'inproc://pipe')
.endif

        # Socket
        self.uri = ''
.if (class->socket.type = "SUB")
        self.topics = set()
.endif
        # more efficient to reuse a protobuf message
        self.rx = Container()
        self.tx = Container()

.for heartbeat
        # $(Name)
        self.$(name)_period = $(period)
        self.$(name)_error_count = 0
        self.$(name)_error_threshold = $(error_threshold)
        self.$(name)_timer = None
        self.$(name)_active = False

.endfor
        self.message_received_cb = None
        self.state_changed_cb = None
        self.started = False

.for fsm
        # fsm
        self.fsm = Fysom({'initial': '$(initial)',
                          'events': [
.  for state
.    for event
                            {'name': '$(name)', 'src': '$(state.name)', 'dst': '$(next)'},
.    endfor
.  endfor
                          ]})

.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(on_$(name:c)))
.        on_$(name:c) = 1
        self.fsm.on$(name:c) = self.on_fsm_$(name:c)
.      endif
.    endfor
.  endfor
.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(fsm_on_$(name:c)))
.        fsm_on_$(name:c) = 1

    def on_fsm_$(name:c)(self, e):
        if self.debuglevel > 0:
            print('[%s]: event $(NAME)' % self.debugname)
.      for action
        self.$(name:c)()
.      endfor
        return True
.      endif
.    endfor
.  endfor
.endfor
.
.if (class->socket.type = "SUB")

    def add_topic(self, name):
        self.topics.add(name)

    def removce_topic(self, name):
        self.topics.remove(name)

    def clear_topics(self):
        self.topics.clear()
.endif

    def socket_worker(self, context, uri):
        poll = zmq.Poller()
.for socket
        socket = context.socket(zmq.$(TYPE))
        socket.setsockopt(zmq.LINGER, 0)
.  if (nature = "client")
        socket.connect(uri)
.  else
        socket.bind(uri)
.  endif
.endfor
        poll.register(socket, zmq.POLLIN)
        shutdown = context.socket(zmq.PULL)
        shutdown.connect(b'inproc://shutdown')
        poll.register(shutdown, zmq.POLLIN)
.if (count(outgoing) > 0)
        pipe = context.socket(zmq.PULL)
        pipe.connect(b'inproc://pipe')
        poll.register(pipe, zmq.POLLIN)
.endif

        while True:
            s = dict(poll.poll())
            if shutdown in s:
                shutdown.recv()
                return  # shutdown signal
.if (count(outgoing) > 0)
            if pipe in s:
                socket.send(pipe.recv(), zmq.NOBLOCK)
.endif
            if socket in s:
                self.socket_message_received(socket)

    def socket_message_received(self, socket):
.if (class->socket.type = "SUB")
        (topic, msg) = socket.recv_multipart()
.else
        msg = socket.recv()
.endif
        self.rx.ParseFromString(msg)
        if self.debuglevel > 0:
            print('[%s] received message' % self.debugname)
            if self.debuglevel > 1:
                print(self.rx)
.
.for incoming
.  if (defined(response) | (count(action) > 0) | (count(event) > 0))

.    if (name <> "*")
.      ws = "    "
        if self.rx.type == MT_$(NAME:c):
.    else
.      ws = ""
.    endif
.
.    if (defined(response))
        $(ws)self.send_$(response:c)()
.    endif
.
.    for action
        $(ws)self.$(name:c)()
.    endfor
.
.    for event
        $(ws)if self.fsm.isstate('$(when)'):
            $(ws)self.fsm.$(name)()
.    endfor
.
.    if (defined(ignore) & ignore = "true")
     $(ws)return  # $(incoming.name) is uninteresting
.    endif
.  endif
.endfor

.if (class->socket.type = "SUB")
        self.message_received_cb(topic, self.rx)
.else
        self.message_received_cb(self.rx)
.endif

    def start(self):
        if self.started:
            return
        self.fsm.connect()  # todo
        self.started = True

    def stop(self):
        if not self.started:
            return
        self.fsm.disconnect()
        self.started = False

    def connect_sockets(self):
        self.thread = threading.Thread(target=self.socket_worker,
                                       args=(self.context, self.uri,))
        self.thread.start()

    def disconnect_sockets(self):
        self.shutdown.send('')  # trigger socket thread shutdown
        self.thread.join()
        self.thread = None
.
.if (class->socket.type = "SUB")

    def subscribe(self):
        for topic in self.topics:
            self.socket.setsockopt(zmq.SUBSCRIBE, topic)
.endif
.
.for heartbeat

    def $(name)_timer_tick(self):
        with self.timer_lock:
            self.$(name)_timer = None  # timer is dead on tick

        if self.debuglevel > 0:
            print('[%s] $(name) timer tick' % self.debugname)
.  for tick
.    for action
        self.$(name:c)()
.    endfor
.  endfor
        self.$(name)_error_count += 1

        if self.$(name)_error_count > self.$(name)_error_threshold:
.  for timeout
.    for event
            if self.fsm.isstate('$(when)'):
                self.fsm.$(name)()
.    endfor
.  endfor

    def reset_$(name)_error(self):
        self.$(name)_error_count = 0

    def reset_$(name)_timer(self):
        if not self.$(name)_active:
            return

        self.timer_lock.acquire()
        if self.$(name)_timer:
            self.$(name)_timer.cancel()
            self.$(name)_timer = None

        if self.$(name)_period > 0:
            self.$(name)_timer = threading.Timer(self.$(name)_period / 1000,
                                                 self.$(name)_timer_tick)
            self.$(name)_timer.start()
        self.timer_lock.release()
        if self.debuglevel > 0:
            print('[%s] $(name) timer reset' % self.debugname)

    def start_$(name)_timer(self):
        self.$(name)_active = True
        self.reset_$(name)_timer()

    def stop_$(name)_timer(self):
        self.$(name)_active = False
        self.timer_lock.acquire()
        if self.$(name)_timer:
            self.$(name)_timer.cancel()
            self.$(name)_timer = None
        self.timer_lock.release()
.endfor
.
.if (count(outgoing) > 0)

    def send_message(self, msg_type, tx):
        with self.tx_lock:
            tx.type = msg_type
            if self.debuglevel > 0:
                print('[%s] sending message: %s' % (self.debugname, msg_type))
                if self.debuglevel > 1:
                    print(str(tx))

            self.pipe.send(tx.SerializeToString())
            tx.Clear()
.
.  for outgoing
.  if ((count(action) > 0) | (count(event) > 0))

.    if (name <> "*")
.      ws = "    "
        if msg_type == MT_$(NAME:c):
.    else
.      ws = ""
.    endif
.
.    for action
        $(ws)self.$(name:c)()
.    endfor
.
.    for event
        $(ws)self.fsm.$(name)()
.    endfor
.  endif
.  endfor
.endif
.
.for outgoing where (name <> "*")

    def send_$(name:c)(self):
        self.send_message(MT_$(NAME:c), self.tx)
.endfor

.endtemplate
