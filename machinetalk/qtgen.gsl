.###  This whole script runs in template mode.
.#
.# Generates a low level Qt/C++ Machinetalk channel
.#
.template 1
.output "generated/$(class.name:Pascal,lower).h"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#ifndef $(class.NAME:c)_H
#define $(class.NAME:c)_H
#include <QObject>
#include <QStateMachine>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include <google/protobuf/text_format.h>

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

class $(class.name:lower,Pascal) : public QObject
{
    Q_OBJECT
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
    Q_PROPERTY(QString uri READ uri WRITE setUri NOTIFY uriChanged)
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(SocketState socketState READ socketState NOTIFY socketStateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
.for heartbeat
    Q_PROPERTY(int $(name)Period READ $(name)Period WRITE set$(Name)Period NOTIFY $(name)PeriodChanged)
.endfor
    Q_ENUMS(SocketState)

public:
    explicit $(class.name:lower,Pascal)(QObject *parent = 0);
    ~$(class.name:lower,Pascal)();

.for fsm
    enum SocketState {
.  enum_index = 0
.  for state
        Socket$(Name) = $(enum_index),
.  enum_index += 1
.  endfor
    };
.endfor

    QString uri() const
    {
        return m_uri;
    }

    QString debugName() const
    {
        return m_debugName;
    }

    SocketState socketState() const
    {
        return m_socketState;
    }

    QString errorString() const
    {
        return m_errorString;
    }
.for heartbeat

    int $(name)Period() const
    {
        return m_heartbeatPeriod;
    }
.endfor

    bool ready() const
    {
        return m_ready;
    }

public slots:

    void setUri(QString uri)
    {
        if (m_uri == uri)
            return;

        m_uri = uri;
        emit uriChanged(uri);
    }

    void setDebugName(QString debugName)
    {
        if (m_debugName == debugName)
            return;

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }
.for heartbeat

    void set$(Name)Period(int $(name)Period)
    {
        if (m_$(name)Period == $(name)Period)
            return;

        m_$(name)Period = $(name)Period;
        emit $(name)PeriodChanged($(name)Period);
    }
.endfor

    void setReady(bool ready)
    {
        if (m_ready == ready)
            return;

        m_ready = ready;
        emit readyChanged(ready);

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }
.
.if (count(outgoing) > 0)

.  if (class->socket.type = "PUB")
    void sendMessage(const QByteArray &topic, pb::ContainerType type, pb::Container *tx);
.  else
    void sendMessage(pb::ContainerType type, pb::Container *tx);
.  endif
.endif
.
.if (class->socket.type = "SUB")
    void addTopic(const QString &name);
    void removeTopic(const QString &name);
    void clearTopics();
.endif

private:
    bool m_ready;
    QString m_uri;
    QString m_debugName;
.if (class->socket.type = "SUB")
    QSet<QString> m_topics;  // the topics we are interested in
.endif

    SocketNotifierZMQContext *m_context;
    ZMQSocket  *m_socket;
    SocketState m_socketState;
    QStateMachine *m_fsm;
    QString     m_errorString;
.for heartbeat

    QTimer     *m_$(name)Timer;
    int         m_$(name)Period;
    int         m_$(name)ErrorCount;
    int         m_$(name)ErrorThreshold;
.endfor
    // more efficient to reuse a protobuf Messages
.if (count(incoming) > 0)
    pb::Container m_rx;
.endif
    pb::Container m_tx;

    void start();
    void stop();

private slots:
.for heartbeat
    void $(name)TimerTick();
    void reset$(Name)Error();
    void reset$(Name)Timer();
    void start$(Name)Timer();
    void stop$(Name)Timer();
.endfor
.if (count(incoming) > 0)
    void socketMessageReceived(QList<QByteArray> messageList);
.endif
    void socketError(int errorNum, const QString& errorMsg);

    bool connectSockets();
    void disconnectSockets();
.if (class->socket.type = "SUB")
    void subscribe();
.endif

.for outgoing where (name <> "*")
.  if (class->socket.type = "PUB")
    void send$(name:Pascal)(const QByteArray &topic);
.  else
    void send$(name:Pascal)();
.  endif
.endfor

.for fsm
.  for state
    void fsm$(Name)Entered();
.  endfor
.endfor

signals:

.if (count(incoming) > 0)
.  if (class->socket.type = "SUB")
    void messageReceived(QByteArray topic, pb::Container *rx);
.  else
    void messageReceived(pb::Container *rx);
.  endif
.endif
    void uriChanged(QString uri);
    void debugNameChanged(QString debugName);
    void socketStateChanged($(class.name:lower,Pascal)::SocketState socketState);
    void errorStringChanged(QString errorString);
.for heartbeat
    void $(name)PeriodChanged(int $(name)Period);
.endfor
    void readyChanged(bool ready);
.for fsm
.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(fsm$(Name)))
.        fsm$(Name) = 1
    void fsm$(Name)();
.      endif
.    endfor
.  endfor
.endfor
};

#endif //$(class.NAME:c)_H
.endtemplate
.
.############################################################################
.# Cpp file
.############################################################################
.
.template 1
.output "generated/$(class.name:Pascal,lower).cpp"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "$(class.name:Pascal,lower).h"
#include "debughelper.h"

/** Generic $(class.name:) implementation */
$(class.name:lower,Pascal)::$(class.name:lower,Pascal)(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_uri(""),
    m_debugName(""),
    m_context(NULL),
    m_socket(NULL),
.for fsm
    m_socketState(Socket$(Initial)),
.endfor
    m_fsm(NULL),
    m_errorString("")
.for heartbeat
    ,m_$(name)Timer(new QTimer(this)),
    m_$(name)Period($(period)),
    m_$(name)ErrorCount(0),
    m_$(name)ErrorThreshold($(error_threshold))
.endfor
{
.for heartbeat
    m_$(name)Timer->setSingleShot(true);
    connect(m_$(name)Timer, SIGNAL(timeout()), this, SLOT($(name)TimerTick()));
.endfor

.for fsm
    m_fsm = new QStateMachine(parent);
.  for state
    QState *$(name)State = new QState(m_fsm);
    connect($(name)State, SIGNAL(entered()), this, SLOT(fsm$(Name)Entered()));
.  endfor
    m_fsm->setInitialState($(initial)State);
    m_fsm->start();

.  for state
.    for event
    $(state.name)State->addTransition(this, SIGNAL(fsm$(Name)()), $(next)State);
.    endfor
.  endfor

.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(signal$(Name)))
.        signal$(Name) = 1
.      for action
    connect(this, SIGNAL(fsm$(event.Name)()), this, SLOT($(name:Camel)()));
.      endfor
.      endif
.    endfor
.  endfor
.endfor

    m_context = new SocketNotifierZMQContext(this, 1);
    connect(m_context, SIGNAL(notifierError(int,QString)),
            this, SLOT(socketError(int,QString)));
    m_context->start();
}

$(class.name:lower,Pascal)::~$(class.name:lower,Pascal)()
{
    if (m_ready)
    {
        stop();
    }

    if (m_context != NULL)
    {
        m_context->stop();
        m_context->deleteLater();
        m_context = NULL;
    }
}
.
.if (class->socket.type = "SUB")

/** Add a topic that should be subscribed **/
void $(class.name:lower,Pascal)::addTopic(const QString &name)
{
    m_topics.insert(name);
}

/** Removes a topic from the list of topics that should be subscribed **/
void $(class.name:lower,Pascal)::removeTopic(const QString &name)
{
    m_topics.remove(name);
}

/** Clears the the topics that should be subscribed **/
void $(class.name:lower,Pascal)::clearTopics()
{
    m_topics.clear();
}
.endif

/** Connects the 0MQ sockets */
bool $(class.name:lower,Pascal)::connectSockets()
{
.for socket
    m_socket = m_context->createSocket(ZMQSocket::TYP_$(TYPE), this);
.endfor
    m_socket->setLinger(0);

    try {
        m_socket->connectTo(m_uri);
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString);
        return false;
    }
.if (count(incoming) > 0)

    connect(m_socket, SIGNAL(messageReceived(QList<QByteArray>)),
            this, SLOT(socketMessageReceived(QList<QByteArray>)));
.endif

#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "sockets connected" << m_uri);
#endif

    return true;
}

/** Disconnects the 0MQ sockets */
void $(class.name:lower,Pascal)::disconnectSockets()
{
    if (m_socket != NULL)
    {
        m_socket->close();
        m_socket->deleteLater();
        m_socket = NULL;
    }
}
.
.if (class->socket.type = "SUB")

void $(class.name:lower,Pascal)::subscribe()
{
    foreach(QString topic, m_topics)
    {
        m_socket->subscribeTo(topic.toLocal8Bit());
    }
}
.endif

void $(class.name:lower,Pascal)::start()
{
#ifdef QT_DEBUG
   DEBUG_TAG(1, m_debugName, "start");
#endif

   emit fsmConnect();
}

void $(class.name:lower,Pascal)::stop()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "stop");
#endif

    emit fsmDisconnect();
}

.for heartbeat

void $(class.name:lower,Pascal)::reset$(Name)Error()
{
    m_$(name)ErrorCount = 0;
}

void $(class.name:lower,Pascal)::reset$(Name)Timer()
{
    if (m_$(name)Timer->isActive())
    {
        m_$(name)Timer->stop();
    }

    if (m_$(name)Period > 0)
    {
        m_$(name)Timer->setInterval(m_$(name)Period);
        m_$(name)Timer->start();
    }
}

void $(class.name:lower,Pascal)::start$(Name)Timer()
{
    reset$(Name)Timer();
}

void $(class.name:lower,Pascal)::stop$(Name)Timer()
{
    m_$(name)Timer->stop();
}

void $(class.name:lower,Pascal)::$(name)TimerTick()
{
.  for tick
.    for action
    $(name:Camel)();
.    endfor
.  endfor

    m_$(name)ErrorCount += 1;

    if (m_$(name)ErrorCount > m_$(name)ErrorThreshold)
    {
.  for timeout
.    for event
         if (m_socketState == Socket$(When))
         {
             emit fsm$(Name)();
         }
.    endfor
.  endfor
    }
}
.endfor
.
.if (count(incoming) > 0)

/** Processes all message received on the 0MQ socket */
void $(class.name:lower,Pascal)::socketMessageReceived(QList<QByteArray> messageList)
{
.  if (class->socket.type = "SUB")
    QByteArray topic;

    if (messageList.length() < 2)  // in case we received insufficient data
    {
        return;
    }

    // we only handle the first two messges
    topic = messageList.at(0);
    m_rx.ParseFromArray(messageList.at(1).data(), messageList.at(1).size());
.  else
    m_rx.ParseFromArray(messageList.at(0).data(), messageList.at(0).size());
.  endif

#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(m_rx, &s);
    DEBUG_TAG(3, m_debugName, "server message" << QString::fromStdString(s));
#endif
.
.  for incoming
.    if (defined(ignore) | (count(action) > 0) | (count(event) > 0))

.      if (name <> "*")
.        ws = "    "
    // react to $(name) message
    if (m_rx.type() == pb::MT_$(NAME:c))
    {
.      else
.        ws = ""
    // react to any incoming message
.      endif
.
.      if (defined(response))
    $(ws)send$(response:Pascal)();
.      endif
.
.      for action
    $(ws)$(name:Camel)();
.      endfor
.
.      for pparams
    $(ws)if (m_rx.has_pparams())
    $(ws){
        $(ws)pb::ProtocolParameters pparams = m_rx.pparams();
        $(ws)m_heartbeatPeriod = pparams.keepalive_timer();
    $(ws)}
.      endfor
.
.      for event
    $(ws)if (m_socketState == Socket$(When))
    $(ws){
        $(ws)emit fsm$(Name)();
    $(ws)}
.      endfor
.
.      if (defined(ignore) & ignore = "true")
    $(ws)return;
.      endif
.      if (name <> "*")
    }
.      endif
.    endif
.  endfor
.

.  if (class->socket.type = "SUB")
    emit messageReceived(topic, &m_rx);
.  else
    emit messageReceived(&m_rx);
.  endif
}
.endif
.
.if (count(outgoing) > 0)

.  if (class->socket.type = "PUB")
void $(class.name:lower,Pascal)::sendMessage(const QByteArray &topic, pb::ContainerType type, pb::Container *tx)
.  else
void $(class.name:lower,Pascal)::sendMessage(pb::ContainerType type, pb::Container *tx)
.  endif
{
    if (m_socket == NULL) {  // disallow sending messages when not connected
        return;
    }

    try {
        tx->set_type(type);
#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(*tx, &s);
    DEBUG_TAG(3, m_debugName, "sent message" << QString::fromStdString(s));
#endif
.  if (class->socket.type = "PUB")
        // TODO
        m_socket->sendMessage(QByteArray(tx->SerializeAsString().c_str(), tx->ByteSize()));
.  else
        m_socket->sendMessage(QByteArray(tx->SerializeAsString().c_str(), tx->ByteSize()));
.  endif
        tx->Clear();
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString);
    }
.
.  for outgoing
.  if ((count(action) > 0) | (count(event) > 0))

.    if (name <> "*")
.      ws = "    "
    if (type == pb::MT_$(NAME:c))
    {
.    else
.      ws = ""
.    endif
.
.    for action
    $(ws)$(name:Camel)();
.    endfor
.
.    for event
    $(ws)emit fsm$(Name)();
.    endfor
.    if (name <> "*")
    }
.    endif
.  endif
.  endfor
}
.endif
.
.for outgoing where (name <> "*")

.  if (class->socket.type = "PUB")
void $(class.name:lower,Pascal)::send$(name:Pascal)(const QByteArray &topic)
{
    sendMessage(topic, pb::MT_$(NAME:c), &m_tx);
}
.  else
void $(class.name:lower,Pascal)::send$(name:Pascal)()
{
    sendMessage(pb::MT_$(NAME:c), &m_tx);
}
.  endif
.endfor

void $(class.name:lower,Pascal)::socketError(int errorNum, const QString &errorMsg)
{
    QString errorString;
    errorString = QString("Error %1: ").arg(errorNum) + errorMsg;
    //updateState(SocketError, errorString);
}
.
.for fsm
.  for state

void $(class.name:lower,Pascal)::fsm$(Name)Entered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "$(NAME)");
#endif
    m_socketState = Socket$(Name);
    emit socketStateChanged(m_socketState);
}
.  endfor
.endfor

.endtemplate
