.###  This whole script runs in template mode.
.#
.# Generates a low level Qt/C++ Machinetalk channel
.#
.template 1
.gsl from "prepare_fsm.gsl"
.output "generated/$(class.name:Pascal,lower).h"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#ifndef $(class.NAME:c)_H
#define $(class.NAME:c)_H
#include <QObject>
#include <QStateMachine>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include <google/protobuf/text_format.h>
.for socket where (defined(kind))
#include "$(kind:Pascal,lower).h"
.endfor

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

class $(class.name:lower,Pascal) : public QObject
{
    Q_OBJECT
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
.for socket
    Q_PROPERTY(QString $(name)Uri READ $(name)Uri WRITE set$(Name)Uri NOTIFY $(name)UriChanged)
.endfor
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State state READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
.for heartbeat
    Q_PROPERTY(int $(name)Period READ $(name)Period WRITE set$(Name)Period NOTIFY $(name)PeriodChanged)
.endfor
    Q_ENUMS(State)

public:
    explicit $(class.name:lower,Pascal)(QObject *parent = 0);
    ~$(class.name:lower,Pascal)();

.for fsm
    enum State {
.  for state
        $(Name) = $(index(state)-1),
.  endfor
    };
.endfor
.
.for socket

    QString $(name)Uri() const
    {
.  if defined(kind)
        return m_$(name)Channel->socketUri();
.  else
        return m_$(name)Uri;
.  endif
    }
.endfor

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }
.for heartbeat

    int $(name)Period() const
    {
        return m_heartbeatPeriod;
    }
.endfor

    bool ready() const
    {
        return m_ready;
    }

public slots:
.for socket

    void set$(Name)Uri(QString uri)
    {
.  if defined(kind)
        m_$(name)Channel->setSocketUri(uri);
.  else
        if (m_$(name)Uri == uri)
            return;

        m_$(name)Uri = uri;
        emit $(name)UriChanged(uri);
.  endif
    }
.endfor

    void setDebugName(QString debugName)
    {
        if (m_debugName == debugName)
            return;

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }
.for heartbeat

    void set$(Name)Period(int $(name)Period)
    {
        if (m_$(name)Period == $(name)Period)
            return;

        m_$(name)Period = $(name)Period;
        emit $(name)PeriodChanged($(name)Period);
    }
.endfor

    void setReady(bool ready)
    {
        if (m_ready == ready)
            return;

        m_ready = ready;
        emit readyChanged(ready);

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }
.
.for socket
.  if (count(outgoing) > 0)

.    if (type = "PUB")
    void send$(Name)Message(const QByteArray &topic, pb::ContainerType type, pb::Container *tx);
.    else
    void send$(Name)Message(pb::ContainerType type, pb::Container *tx);
.    endif
.  endif
.
.  for outgoing where ((name <> "*") & (defined(public)))
.    if (socket.type = "PUB")
    void send$(name:Pascal)(const QByteArray &topic, pb::Container *tx);
.    else
    void send$(name:Pascal)(pb::Container *tx);
.    endif
.  endfor
.endfor
.
.for socket
.  if (type = "SUB")
    void add$(Name)Topic(const QString &name);
    void remove$(Name)Topic(const QString &name);
    void clear$(Name)Topics();
.  endif
.endfor

private:
    bool m_ready;
    QString m_socketUri;
    QString m_debugName;

.for socket
.  if (type = "SUB")
    QSet<QString> m_$(name)Topics;  // the topics we are interested in
.  endif
.  if defined(kind)
    $(kind:lower,Pascal) *m_$(name)Channel;
.  else
    SocketNotifierZMQContext *m_context;
    ZMQSocket  *m_socket;
.  endif
.endfor
.

    State         m_state;
    QStateMachine *m_fsm;
    QString       m_errorString;
.
.for heartbeat

    QTimer     *m_$(name)Timer;
    int         m_$(name)Period;
    int         m_$(name)ErrorCount;
    int         m_$(name)ErrorThreshold;
.endfor
    // more efficient to reuse a protobuf Messages
.for socket
.  if (count(incoming) > 0)
    pb::Container m_$(name)Rx;
.  endif
.  if (count(outgoing) > 0)
    pb::Container m_$(name)Tx;
.  endif
.endfor

    void start();
    void stop();

private slots:
.for heartbeat

    void $(name)TimerTick();
    void reset$(Name)Error();
    void reset$(Name)Timer();
    void start$(Name)Timer();
    void stop$(Name)Timer();
.endfor
.
.for socket

.  if defined(kind)
    void start$(Name)Channel();
    void stop$(Name)Channel();
.    if (count(state) > 0)
    void $(name)ChannelStateChanged($(kind:lower,Pascal)::State state);
.    endif
.    if (count(incoming) > 0)
.      if (type = "SUB")
    void $(name)ChannelMessageReceived(const QByteArray &topic, pb::Container *rx);
.      else
    void $(name)ChannelMessageReceived(pb::Container *rx);
.      endif
.    endif
.  else
    bool connectSockets();
    void disconnectSockets();

.    if (count(incoming) > 0)
    void socketMessageReceived(QList<QByteArray> messageList);
.    endif
    void socketError(int errorNum, const QString& errorMsg);

.  endif
.
.  for outgoing where ((name <> "*") & (!defined(public)))
.    if (socket.type = "PUB")
    void send$(name:Pascal)(const QByteArray &topic);
.    else
    void send$(name:Pascal)();
.    endif
.  endfor
.endfor
.

.for fsm
.  for state
    void fsm$(Name)Entered();
.  endfor
.endfor
.
.for slot
    virtual void $(name:Camel)() { qWarning() << "SLOT $(name) unimplemented"; }
.endfor

signals:

.for socket
    void $(name)UriChanged(QString uri);
.endfor
.
.for socket
.  if (count(incoming) > 0)
.    if (type = "SUB")
    void $(name)MessageReceived(QByteArray topic, pb::Container *rx);
.    else
    void $(name)MessageReceived(pb::Container *rx);
.    endif
.  endif
.endfor
.
    void debugNameChanged(QString debugName);
    void stateChanged($(class.name:lower,Pascal)::State state);
    void errorStringChanged(QString errorString);
.for heartbeat
    void $(name)PeriodChanged(int $(name)Period);
.endfor
    void readyChanged(bool ready);
    // fsm
.for fsm
.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(fsm$(Name:Pascal)))
.        fsm$(Name:Pascal) = 1
    void fsm$(Name:Pascal)();
.      endif
.    endfor
.  endfor
.endfor
};

#endif //$(class.NAME:c)_H
.endtemplate
.
.############################################################################
.# Cpp file
.############################################################################
.
.template 1
.output "generated/$(class.name:Pascal,lower).cpp"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "$(class.name:Pascal,lower).h"
#include "debughelper.h"

/** Generic $(class.name:) implementation */
$(class.name:lower,Pascal)::$(class.name:lower,Pascal)(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_socketUri(""),
    m_debugName("$(class.name:)"),
.for socket
.  if defined(kind)
    m_$(name)Channel(NULL),
.  else
    m_context(NULL),
    m_socket(NULL),
.  endif
.endfor
    m_state($(class->fsm.Initial)),
    m_fsm(NULL),
    m_errorString("")
.for heartbeat
    ,m_$(name)Timer(new QTimer(this)),
    m_$(name)Period($(period)),
    m_$(name)ErrorCount(0),
    m_$(name)ErrorThreshold($(error_threshold))
.endfor
{
.for socket where defined(kind)
    // initialize $(name) channel
    m_$(name)Channel = new $(kind:lower,Pascal)(this);
    m_$(name)Channel->setDebugName(m_debugName + " - $(name:)");
    connect(m_$(name)Channel, SIGNAL(socketUriChanged(QString)),
            this, SIGNAL($(name)UriChanged(QString)));
.  if (count(state) > 0)
    connect(m_$(name)Channel, SIGNAL(stateChanged($(kind:lower,Pascal)::State)),
            this, SLOT($(name)ChannelStateChanged($(kind:lower,Pascal)::State)));
.  endif
.  if (count(incoming) > 0)
.    if (socket.type = "SUB")
    connect(m_$(name)Channel, SIGNAL(socketMessageReceived(QByteArray, pb::Container*)),
            this, SLOT($(name)ChannelMessageReceived(QByteArray, pb::Container*)));
.    else
    connect(m_$(name)Channel, SIGNAL(socketMessageReceived(pb::Container*)),
            this, SLOT($(name)ChannelMessageReceived(pb::Container*)));
.    endif
.  endif
.endfor
.
.for heartbeat

    m_$(name)Timer->setSingleShot(true);
    connect(m_$(name)Timer, SIGNAL(timeout()), this, SLOT($(name)TimerTick()));
.endfor

.for fsm
    m_fsm = new QStateMachine(parent);
.  for state
    QState *$(name:Camel)State = new QState(m_fsm);
    connect($(name:Camel)State, SIGNAL(entered()), this, SLOT(fsm$(Name:Pascal)Entered()));
.  endfor
    m_fsm->setInitialState($(initial:Camel)State);
    m_fsm->start();

.  for state
.    for event
    $(state.name:Camel)State->addTransition(this, SIGNAL(fsm$(Name:Pascal)()), $(next:Camel)State);
.    endfor
.  endfor

.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(signal$(Name:Pascal)))
.        signal$(Name:Pascal) = 1
.      for action
    connect(this, SIGNAL(fsm$(event.name:Pascal)()), this, SLOT($(name:Camel)()));
.      endfor
.      endif
.    endfor
.  endfor
.endfor
.
.for socket where !defined(kind)

    m_context = new SocketNotifierZMQContext(this, 1);
    connect(m_context, SIGNAL(notifierError(int,QString)),
            this, SLOT(socketError(int,QString)));
    m_context->start();
.endfor
}

$(class.name:lower,Pascal)::~$(class.name:lower,Pascal)()
{
    if (m_ready)
    {
        stop();
    }
.for socket where !defined(kind)

    if (m_context != NULL)
    {
        m_context->stop();
        m_context->deleteLater();
        m_context = NULL;
    }
.endfor
}
.
.for socket
.  if (type = "SUB")

/** Add a topic that should be subscribed **/
void $(class.name:lower,Pascal)::add$(Name)Topic(const QString &name)
{
.    if defined(kind)
    m_$(name)Channel->addSocketTopic(name);
.    else
    m_$(name)Topics.insert(name);
.    endif
}

/** Removes a topic from the list of topics that should be subscribed **/
void $(class.name:lower,Pascal)::remove$(Name)Topic(const QString &name)
{
.    if defined(kind)
    m_$(name)Channel->removeSocketTopic(name);
.    else
    m_$(name)Topics.remove(name);
.    endif
}

/** Clears the the topics that should be subscribed **/
void $(class.name:lower,Pascal)::clear$(Name)Topics()
{
.    if defined(kind)
    m_$(name)Channel->clearSocketTopics();
.    else
    m_$(name)Topics.clear();
.    endif
}
.  endif
.
.  if !defined(kind)

/** Connects the 0MQ sockets */
bool $(class.name:lower,Pascal)::connectSockets()
{
    m_socket = m_context->createSocket(ZMQSocket::TYP_$(TYPE), this);
    m_socket->setLinger(0);

    try {
        m_socket->connectTo(m_socketUri);
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString); TODO
        return false;
    }
.    if (count(incoming) > 0)

    connect(m_socket, SIGNAL(messageReceived(QList<QByteArray>)),
            this, SLOT(socketMessageReceived(QList<QByteArray>)));
.    endif

.    if (type = "SUB")

    foreach(QString topic, m_socketTopics)
    {
        m_socket->subscribeTo(topic.toLocal8Bit());
    }
.    endif

#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "sockets connected" << m_socketUri);
#endif

    return true;
}

/** Disconnects the 0MQ sockets */
void $(class.name:lower,Pascal)::disconnectSockets()
{
    if (m_socket != NULL)
    {
        m_socket->close();
        m_socket->deleteLater();
        m_socket = NULL;
    }
}
.
.  endif
.endfor

void $(class.name:lower,Pascal)::start()
{
#ifdef QT_DEBUG
   DEBUG_TAG(1, m_debugName, "start");
#endif

   emit fsmConnect();
}

void $(class.name:lower,Pascal)::stop()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "stop");
#endif

    emit fsmDisconnect();
}
.
.for socket where defined(kind)

void $(class.name:lower,Pascal)::start$(Name)Channel()
{
    m_$(name)Channel->setReady(true);
}

void $(class.name:lower,Pascal)::stop$(Name)Channel()
{
    m_$(name)Channel->setReady(false);
}
.endfor
.
.for heartbeat

void $(class.name:lower,Pascal)::reset$(Name)Error()
{
    m_$(name)ErrorCount = 0;
}

void $(class.name:lower,Pascal)::reset$(Name)Timer()
{
    if (m_$(name)Timer->isActive())
    {
        m_$(name)Timer->stop();
    }

    if (m_$(name)Period > 0)
    {
        m_$(name)Timer->setInterval(m_$(name)Period);
        m_$(name)Timer->start();
    }
}

void $(class.name:lower,Pascal)::start$(Name)Timer()
{
    reset$(Name)Timer();
}

void $(class.name:lower,Pascal)::stop$(Name)Timer()
{
    m_$(name)Timer->stop();
}

void $(class.name:lower,Pascal)::$(name)TimerTick()
{
    m_$(name)ErrorCount += 1;
    if (m_$(name)ErrorCount > m_$(name)ErrorThreshold)
    {
.  for timeout
.    for action
         $(name:Camel)();
.    endfor
.    for event
         if (m_state == $(when:Pascal))
         {
             emit fsm$(name:Pascal)();
         }
.    endfor
.  endfor
    }
    else
    {
.  for tick
.    for action
         $(name:Camel)();
.    endfor
.    for event
         if (m_state == $(when:Pascal))
         {
             emit fsm$(name:Pascal)();
         }
.    endfor
.  endfor
    }
}
.endfor
.
.for socket where (count(incoming) > 0)

/** Processes all message received on $(name:) */
.  if defined(kind)
.    if (type = "SUB")
void $(class.name:lower,Pascal)::$(name)ChannelMessageReceived(const QByteArray &topic, pb::Container *rx)
.    else
void $(class.name:lower,Pascal)::$(name)ChannelMessageReceived(pb::Container *rx)
.    endif
{
.  else
void $(class.name:lower,Pascal)::socketMessageReceived(QList<QByteArray> messageList)
{
    pb::Container *rx = &m_$(name)Rx;
.    if (type = "SUB")
    QByteArray topic;

    if (messageList.length() < 2)  // in case we received insufficient data
    {
        return;
    }

    // we only handle the first two messges
    topic = messageList.at(0);
    rx->ParseFromArray(messageList.at(1).data(), messageList.at(1).size());
.    else
    rx->ParseFromArray(messageList.at(0).data(), messageList.at(0).size());
.    endif

#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(*rx, &s);
    DEBUG_TAG(3, m_debugName, "server message" << QString::fromStdString(s));
#endif
.  endif
.
.  for incoming
.    if (defined(ignore) | (count(action) > 0) | (count(event) > 0))

.      if (name <> "*")
.        ws = "    "
    // react to $(name) message
    if (rx->type() == pb::MT_$(NAME:c))
    {
.      else
.        ws = ""
    // react to any incoming message
.      endif
.
.      for response
    $(ws)send$(name:Pascal)();
.      endfor
.
.      for action
    $(ws)$(name:Camel)();
.      endfor
.
.      for pparams
    $(ws)if (rx->has_pparams())
    $(ws){
        $(ws)pb::ProtocolParameters pparams = rx->pparams();
        $(ws)m_heartbeatPeriod = pparams.keepalive_timer();
    $(ws)}
.      endfor
.
.      for note

    $(ws)// update error string with note
    $(ws)m_errorString = "";
    $(ws)for (int i = 0; i < rx->note_size(); ++i)
    $(ws){
        $(ws)m_errorString.append(QString::fromStdString(rx->note(i)) + "\\n");
    $(ws)}
    $(ws)emit errorStringChanged(m_errorString);
.      endfor
.
.      for event

    $(ws)if (m_state == $(when:Pascal))
    $(ws){
        $(ws)emit fsm$(name:Pascal)();
    $(ws)}
.      endfor
.
.      if (defined(ignore) & ignore = "true")
    $(ws)return; // $(incoming.name:) is uninteresting
.        endif
.      if (name <> "*")
    }
.      endif
.    endif
.  endfor
.

.  if (type = "SUB")
    emit $(name)MessageReceived(topic, rx);
.  else
    emit $(name)MessageReceived(rx);
.  endif
}
.endfor
.
.for socket where (count(outgoing) > 0)

.  if (type = "PUB")
void $(class.name:lower,Pascal)::send$(Name)Message(const QByteArray &topic, pb::ContainerType type, pb::Container *tx)
.  else
void $(class.name:lower,Pascal)::send$(Name)Message(pb::ContainerType type, pb::Container *tx)
.  endif
{
.  if !defined(kind)
    if (m_socket == NULL) {  // disallow sending messages when not connected
        return;
    }

.  endif
.  if defined(kind)
.    if (type = "PUB")
    m_$(name)Channel->sendSocketMessage(topic, type, tx);
.    else
    m_$(name)Channel->sendSocketMessage(type, tx);
.    endif
.  else
    tx->set_type(type);
#ifdef QT_DEBUG
    std::string s;
    gpb::TextFormat::PrintToString(*tx, &s);
    DEBUG_TAG(3, m_debugName, "sent message" << QString::fromStdString(s));
#endif
    try {
.    if (type = "PUB")
        QList<QByteArray> message;
        message.append(topic);
        message.append(QByteArray(tx->SerializeAsString().c_str(), tx->ByteSize()));
        m_socket->sendMessage(message);
.    else
        m_socket->sendMessage(QByteArray(tx->SerializeAsString().c_str(), tx->ByteSize()));
.    endif
    }
    catch (const zmq::error_t &e) {
        QString errorString;
        errorString = QString("Error %1: ").arg(e.num()) + QString(e.what());
        //updateState(SocketError, errorString);  TODO
        return;
    }
    tx->Clear();
.  endif
.
.  for outgoing where ((count(action) > 0) | (count(event) > 0))
.    if (name <> "*")
.      ws = "    "
    if (type == pb::MT_$(NAME:c))
    {
.    else
.      ws = ""
.    endif
.
.    for action
    $(ws)$(name:Camel)();
.    endfor
.
.    for event

    $(ws)if (m_state == $(when:Pascal))
    $(ws){
        $(ws)emit fsm$(Name:Pascal)();
    $(ws)}
.    endfor
.    if (name <> "*")
    }
.    endif
.  endfor
}
.endfor
.
.for socket
.  for outgoing where (name <> "*")

.    if (socket.type = "PUB")
.      if defined(public)
void $(class.name:lower,Pascal)::send$(name:Pascal)(const QByteArray &topic, pb::Container *tx)
{
.      else
void $(class.name:lower,Pascal)::send$(name:Pascal)(const QByteArray &topic)
{
    pb::Container *tx = &m_$(socket.name)Tx;
.      endif
    send$(socket.Name)Message(topic, pb::MT_$(NAME:c), tx);
}
.    else
.      if defined(public)
void $(class.name:lower,Pascal)::send$(name:Pascal)(pb::Container *tx)
{
.      else
void $(class.name:lower,Pascal)::send$(name:Pascal)()
{
    pb::Container *tx = &m_$(socket.name)Tx;
.      endif
    send$(socket.Name)Message(pb::MT_$(NAME:c), tx);
}
.    endif
.  endfor
.
.  if !defined(kind)

void $(class.name:lower,Pascal)::socketError(int errorNum, const QString &errorMsg)
{
    QString errorString;
    errorString = QString("Error %1: ").arg(errorNum) + errorMsg;
    //updateState(SocketError, errorString);  TODO
}
.  endif
.endfor
.
.for fsm
.  for state

void $(class.name:lower,Pascal)::fsm$(Name)Entered()
{
    if (m_state != $(name:Pascal))
    {
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "$(NAME)");
#endif
        m_state = $(name:Pascal);
        emit stateChanged(m_state);
    }
}
.  endfor
.endfor
.
.for socket where (defined(kind) & (count(state) > 0))

void $(class.name:lower,Pascal)::$(name)ChannelStateChanged($(kind:lower,Pascal)::State state)
{
.  for state where (count(event) > 0)

    if (state == $(socket.kind:lower,Pascal)::$(name:Pascal))
    {
.     for event
        if (m_state == $(when:Pascal))
        {
            emit fsm$(name:Pascal)();
        }
.     endfor
    }
.  endfor
}
.endfor
.endtemplate
