.###  This whole script runs in template mode.
.#
.# Generates a high level Qt/C++ Machinetalk binding
.#
.template 1
.output "generated/$(class.name:Pascal,lower).h"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#ifndef $(class.NAME:c)_H
#define $(class.NAME:c)_H
#include <QObject>
#include <QStateMachine>
#include <nzmqt/nzmqt.hpp>
#include <machinetalk/protobuf/message.pb.h>
#include <google/protobuf/text_format.h>
.for channel
#include "$(type:Pascal,lower).h"
.endfor

#if defined(Q_OS_IOS)
namespace gpb = google_public::protobuf;
#else
namespace gpb = google::protobuf;
#endif

using namespace nzmqt;

class $(class.name:lower,Pascal) : public QObject
{
    Q_OBJECT
    Q_PROPERTY(bool ready READ ready WRITE setReady NOTIFY readyChanged)
.for channel
    Q_PROPERTY(QString $(name)Uri READ $(name)Uri WRITE set$(Name)Uri NOTIFY $(name)UriChanged)
.endfor
    Q_PROPERTY(QString debugName READ debugName WRITE setDebugName NOTIFY debugNameChanged)
    Q_PROPERTY(State state READ state NOTIFY stateChanged)
    Q_PROPERTY(QString errorString READ errorString NOTIFY errorStringChanged)
    Q_ENUMS(State)

public:
    explicit $(class.name:lower,Pascal)(QObject *parent = 0);
    ~$(class.name:lower,Pascal)();

.for fsm
    enum State {
.  enum_index = 0
.  for state
        $(Name) = $(enum_index),
.  enum_index += 1
.  endfor
    };
.endfor
.
.for channel

    QString $(name)Uri() const
    {
        return m_$(name)Channel->uri();
    }
.endfor

    QString debugName() const
    {
        return m_debugName;
    }

    State state() const
    {
        return m_state;
    }

    QString errorString() const
    {
        return m_errorString;
    }

    bool ready() const
    {
        return m_ready;
    }

public slots:
.
.for channel

    void set$(Name)Uri(QString uri)
    {
        m_$(name)Channel->setUri(uri);
    }
.endfor

    void setDebugName(QString debugName)
    {
        if (m_debugName == debugName)
            return;

        m_debugName = debugName;
        emit debugNameChanged(debugName);
    }

    void setReady(bool ready)
    {
        if (m_ready == ready)
            return;

        m_ready = ready;
        emit readyChanged(ready);

        if (m_ready)
        {
            start();
        }
        else
        {
            stop();
        }
    }
.for channel
.  for outgoing where ((name <> "*") & (defined(public)))

    void send$(name:Pascal)(pb::Container *tx);
.  endfor
.endfor

private:
    bool m_ready;
    QString m_uri;
    QString m_debugName;

.for channel
    $(type:lower,Pascal) *m_$(name)Channel;
.endfor
    State m_state;
    QStateMachine *m_fsm;
    QString     m_errorString;

    // more efficient to reuse a protobuf Messages
.if (count(incoming) > 0)
    pb::Container m_rx;
.endif
    pb::Container m_tx;

    void start();
    void stop();

private slots:

.for channel
    void start$(Name)Channel();
    void stop$(Name)Channel();
.endfor
.
.for fsm
.  for state
    void fsm$(Name)Entered();
.  endfor
.endfor
.
.for channel
.  if (count(state) > 0)
    void $(name)ChannelStateChanged($(type:lower,Pascal)::SocketState state);
.  endif
.  for outgoing where ((name <> "*") & (!defined(public)))
    void send$(name:Pascal)();
.  endfor
.endfor

signals:

.for channel
    void $(name)UriChanged(QString uri);
.endfor
    void debugNameChanged(QString debugName);
    void stateChanged($(class.name:lower,Pascal)::State state);
    void errorStringChanged(QString errorString);
    void readyChanged(bool ready);
.for fsm
.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(fsm$(Name:Pascal)))
.        fsm$(Name:Pascal) = 1
    void fsm$(Name:Pascal)();
.      endif
.    endfor
.  endfor
.endfor
};

#endif //$(class.NAME:c)_H
.endtemplate
.
.############################################################################
.# Cpp file
.############################################################################
.
.template 1
.output "generated/$(class.name:Pascal,lower).cpp"
/****************************************************************************
**
** This code was generated by a code generator based on imatix/gsl
** Any changes in this code will be lost.
**
****************************************************************************/
#include "$(class.name:Pascal,lower).h"
#include "debughelper.h"

/** Generic $(class.name:) implementation */
$(class.name:lower,Pascal)::$(class.name:lower,Pascal)(QObject *parent) :
    QObject(parent),
    m_ready(false),
    m_debugName(""),
.for channel
    m_$(name)Channel(NULL),
.endfor
    m_state($(class->fsm.Initial)),
    m_fsm(NULL),
    m_errorString("")
{
.for channel
    // initialize $(name) channel
    m_$(name)Channel = new $(type:lower,Pascal)(this);
    connect(m_$(name)Channel, SIGNAL(uriChanged(QString)),
            this, SIGNAL($(name)UriChanged(QString)));
.  if (count(state) > 0)
    connect(m_$(name)Channel, SIGNAL(socketStateChanged($(type:lower,Pascal)::SocketState)),
            this, SLOT($(name)ChannelStateChanged($(type:lower,Pascal)::SocketState)));
.  endif
.endfor

.for fsm
    m_fsm = new QStateMachine(parent);
.  for state
    QState *$(name)State = new QState(m_fsm);
    connect($(name)State, SIGNAL(entered()), this, SLOT(fsm$(Name)Entered()));
.  endfor
    m_fsm->setInitialState($(initial)State);
    m_fsm->start();

.  for state
.    for event
    $(state.name)State->addTransition(this, SIGNAL(fsm$(name:Pascal)()), $(next)State);
.    endfor
.  endfor

.  for state
.    for event
.-     make sure we assign only once
.      if (!defined(signal$(Name)))
.        signal$(Name) = 1
.      for action
    connect(this, SIGNAL(fsm$(event.Name:Pascal)()), this, SLOT($(name:Camel)()));
.      endfor
.      endif
.    endfor
.  endfor
.endfor
}

$(class.name:lower,Pascal)::~$(class.name:lower,Pascal)()
{
    if (m_ready)
    {
        stop();
    }
}

void $(class.name:lower,Pascal)::start()
{
#ifdef QT_DEBUG
   DEBUG_TAG(1, m_debugName, "start");
#endif

   emit fsmConnect();
}

void $(class.name:lower,Pascal)::stop()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "stop");
#endif

    emit fsmDisconnect();
}
.
.for channel
void $(class.name:lower,Pascal)::start$(Name)Channel()
{
    m_$(name)Channel->setReady(true);
}

void $(class.name:lower,Pascal)::stop$(Name)Channel()
{
    m_$(name)Channel->setReady(false);
}
.endfor
.
.for fsm
.  for state

void $(class.name:lower,Pascal)::fsm$(Name)Entered()
{
#ifdef QT_DEBUG
    DEBUG_TAG(1, m_debugName, "$(NAME)");
#endif
    m_state = $(Name);
    emit stateChanged(m_state);
}
.  endfor
.endfor
.
.for channel
.  if (count(state) > 0)

void $(class.name:lower,Pascal)::$(name)ChannelStateChanged($(type:lower,Pascal)::SocketState state)
{
.    for state

    if (state == $(channel.type:lower,Pascal)::Socket$(Name))
    {
.       for event
        if (m_state == $(When))
        {
            emit fsm$(name:Pascal)();
        }
.       endfor
    }
.    endfor
}
.  endif
.endfor
.
.for channel
.  for outgoing where (name <> "*")

.    if defined(public)
void $(class.name:lower,Pascal)::send$(name:Pascal)(pb::Container *tx)
{
.    else
void $(class.name:lower,Pascal)::send$(name:Pascal)()
{
    pb::Container *tx = &m_tx;
.    endif
    m_$(channel.name)Channel->sendMessage(pb::MT_$(NAME:c), tx);
}
.  endfor
.endfor
.endtemplate
